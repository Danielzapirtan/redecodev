<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Living 002 — Mobile Gyro + Joystick</title>
<style>
  html,body { height:100%; margin:0; -webkit-user-select:none; user-select:none; touch-action: none; overflow: hidden; }
  canvas { display:block; }
  #ui {
    position: absolute; left:0; top:0; right:0; pointer-events:none; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; z-index: 100;
  }
  #topbar {
    pointer-events:auto;
    margin: 10px;
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap: wrap;
  }
  .panel {
    background: rgba(0,0,0,0.6);
    color: white;
    padding:8px 10px;
    border-radius:8px;
    font-size:14px;
  }
  #gyroBtn {
    pointer-events:auto;
    background:#0b84ff;
    border:none;
    color:white;
    padding:8px 10px;
    border-radius:8px;
    font-weight:600;
    cursor:pointer;
    font-size:14px;
  }
  #joystick {
    position: absolute;
    left: 18px;
    bottom: 24px;
    width: 120px;
    height: 120px;
    pointer-events: auto;
    touch-action: none;
    z-index: 100;
  }
  .stickBase {
    width:100%;
    height:100%;
    background: rgba(0,0,0,0.25);
    border-radius: 50%;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .stickThumb {
    width:44px;
    height:44px;
    background: rgba(255,255,255,0.9);
    border-radius:50%;
    transform: translate(0,0);
    will-change: transform;
    box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  }
  #help {
    font-size:12px;
    opacity:0.9;
  }
  #status {
    background: rgba(0,128,0,0.6);
    font-size:12px;
  }
  @media (max-width:420px) {
    #joystick { width: 100px; height:100px; left:12px; bottom:18px; }
    .stickThumb { width:40px; height:40px; }
    #help { display: none; }
  }
</style>
</head>
<body>
<div id="ui">
  <div id="topbar">
    <div class="panel">Living 002 — Tilt phone to look, use joystick to move</div>
    <button id="gyroBtn" class="panel">Enable Motion</button>
    <div id="status" class="panel">Loading Three.js...</div>
    <div id="help" class="panel">Desktop: drag + WASD</div>
  </div>
</div>

<div id="joystick" aria-hidden="true">
  <div class="stickBase">
    <div id="thumb" class="stickThumb"></div>
  </div>
</div>

<!-- Load Three.js from CDN (non-module version) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// Wait for THREE to be available
if (typeof THREE === 'undefined') {
  document.getElementById('status').textContent = 'ERROR: Three.js failed to load';
  document.getElementById('status').style.background = 'rgba(255,0,0,0.6)';
} else {
  initApp();
}

function initApp() {
  var statusEl = document.getElementById('status');
  function setStatus(msg) {
    statusEl.textContent = msg;
    statusEl.style.display = 'block';
    console.log('STATUS:', msg);
  }

  setStatus('Three.js loaded!');

  // Room parameters
  var roomWidth = 5.0;
  var roomDepth = 4.0;
  var roomHeight = 2.2;

  // Three.js setup
  var scene = new THREE.Scene();
  scene.background = new THREE.Color(0xbfd1df);

  var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.05, 50);
  camera.position.set(0, 1.6, 1.5);

  var renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  document.body.appendChild(renderer.domElement);

  setStatus('Renderer ready');

  // Lights
  scene.add(new THREE.HemisphereLight(0xffffff, 0x666666, 1.0));
  var dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(5, 6, 3);
  scene.add(dirLight);

  // Floor & walls
  var floorMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
  var wallMat = new THREE.MeshStandardMaterial({ color: 0xf7f7f7 });

  var floor = new THREE.Mesh(new THREE.PlaneGeometry(roomWidth, roomDepth), floorMat);
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  function addWall(width, height, pos, rotY) {
    var m = new THREE.Mesh(new THREE.PlaneGeometry(width, height), wallMat);
    m.position.set(pos.x, pos.y, pos.z);
    m.rotation.y = rotY;
    scene.add(m);
  }
  
  addWall(roomWidth, roomHeight, {x:0, y:roomHeight/2, z:-roomDepth/2}, 0);
  addWall(roomWidth, roomHeight, {x:0, y:roomHeight/2, z:roomDepth/2}, Math.PI);
  addWall(roomDepth, roomHeight, {x:-roomWidth/2, y:roomHeight/2, z:0}, Math.PI/2);
  addWall(roomDepth, roomHeight, {x:roomWidth/2, y:roomHeight/2, z:0}, -Math.PI/2);

  setStatus('Room created');

  // Doors
  function createDoor() {
    return new THREE.Mesh(
      new THREE.BoxGeometry(0.9, 2.0, 0.05), 
      new THREE.MeshStandardMaterial({color:0x6b4f2c})
    );
  }
  var door1 = createDoor();
  door1.position.set(-roomWidth/2 + 0.05, 1.0, -1.0);
  scene.add(door1);
  
  var door2 = createDoor();
  door2.position.set(0, 1.0, roomDepth/2 - 0.05);
  scene.add(door2);

  // Window
  var windowGroup = new THREE.Group();
  var totalWidth = 1.0;
  var panels = 3;
  var panelWidth = totalWidth / panels;
  
  for (var i = 0; i < panels; i++) {
    var glass = new THREE.Mesh(
      new THREE.PlaneGeometry(panelWidth * 0.95, 1.0),
      new THREE.MeshStandardMaterial({color:0x99ccff, transparent:true, opacity:0.45})
    );
    glass.position.x = (i - (panels/2 - 0.5)) * panelWidth;
    windowGroup.add(glass);
  }
  windowGroup.position.set(roomWidth/2 - 0.02, 1.2, 0);
  windowGroup.rotation.y = -Math.PI/2;
  scene.add(windowGroup);

  // Furniture (colored boxes)
  var sofa = new THREE.Mesh(
    new THREE.BoxGeometry(2.0, 0.8, 1.0),
    new THREE.MeshStandardMaterial({color: 0x8B4513})
  );
  sofa.position.set(-1.5, 0.4, 1.2);
  scene.add(sofa);

  var tv = new THREE.Mesh(
    new THREE.BoxGeometry(1.2, 0.8, 0.2),
    new THREE.MeshStandardMaterial({color: 0x333333})
  );
  tv.position.set(1.8, 0.8, -1.6);
  scene.add(tv);

  var chair1 = new THREE.Mesh(
    new THREE.BoxGeometry(0.6, 0.8, 0.6),
    new THREE.MeshStandardMaterial({color: 0x654321})
  );
  chair1.position.set(1.0, 0.4, 1.3);
  scene.add(chair1);

  var chair2 = new THREE.Mesh(
    new THREE.BoxGeometry(0.6, 0.8, 0.6),
    new THREE.MeshStandardMaterial({color: 0x654321})
  );
  chair2.position.set(0.3, 0.4, 1.6);
  scene.add(chair2);

  var bookcase = new THREE.Mesh(
    new THREE.BoxGeometry(1.5, 2.0, 0.4),
    new THREE.MeshStandardMaterial({color: 0x8B6914})
  );
  bookcase.position.set(-1.5, 1.0, -1.8);
  scene.add(bookcase);

  setStatus('Furniture added');

  // Movement state
  var move = { forward: 0, right: 0 };
  var speed = 1.8;
  var lastTime = performance.now();

  // Gyroscope
  var gyroEnabled = false;
  var initialAlpha = null;
  var gyroBtn = document.getElementById('gyroBtn');

  function handleOrientation(event) {
    if (!gyroEnabled) return;
    
    var alpha = event.alpha || 0;
    var beta = event.beta || 0;
    
    if (initialAlpha === null) {
      initialAlpha = alpha;
      return;
    }
    
    var degToRad = Math.PI / 180;
    camera.rotation.y = -(alpha - initialAlpha) * degToRad;
    camera.rotation.x = -(beta - 90) * degToRad;
    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
  }

  function enableGyro() {
    if (typeof DeviceOrientationEvent !== 'undefined' && 
        typeof DeviceOrientationEvent.requestPermission === 'function') {
      DeviceOrientationEvent.requestPermission().then(function(response) {
        if (response === 'granted') {
          window.addEventListener('deviceorientation', handleOrientation, true);
          gyroEnabled = true;
          gyroBtn.style.display = 'none';
          setStatus('Gyro enabled!');
          setTimeout(function() { statusEl.style.display = 'none'; }, 2000);
        } else {
          setStatus('Motion permission denied');
        }
      }).catch(function(err) {
        console.error('Gyro error:', err);
        setStatus('Gyro error');
      });
    } else {
      window.addEventListener('deviceorientation', handleOrientation, true);
      gyroEnabled = true;
      gyroBtn.style.display = 'none';
      setStatus('Gyro enabled!');
      setTimeout(function() { statusEl.style.display = 'none'; }, 2000);
    }
  }

  gyroBtn.addEventListener('click', enableGyro);

  // Mouse/touch drag look
  var isDragging = false;
  var prevTouch = null;
  var lookSensitivity = 0.0025;
  var joystick = document.getElementById('joystick');

  function onPointerDown(e) {
    var target = e.target;
    if (target === joystick || joystick.contains(target)) return;
    isDragging = true;
    prevTouch = getPointerXY(e);
  }

  function onPointerUp() { 
    isDragging = false; 
    prevTouch = null; 
  }

  function onPointerMove(e) {
    if (!isDragging || gyroEnabled) return;
    var pt = getPointerXY(e);
    if (!prevTouch) { prevTouch = pt; return; }
    
    var dx = pt.x - prevTouch.x;
    var dy = pt.y - prevTouch.y;
    prevTouch = pt;
    
    camera.rotation.y -= dx * lookSensitivity;
    camera.rotation.x -= dy * lookSensitivity;
    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
  }

  function getPointerXY(e) {
    var t = (e.touches && e.touches[0]) || e;
    return { x: t.clientX, y: t.clientY };
  }

  window.addEventListener('pointerdown', onPointerDown);
  window.addEventListener('pointerup', onPointerUp);
  window.addEventListener('pointermove', onPointerMove, {passive: false});

  // Joystick
  var thumb = document.getElementById('thumb');
  var joyActive = false;
  var joyId = null;
  var joyRect = joystick.getBoundingClientRect();
  var center = { x: joyRect.left + joyRect.width/2, y: joyRect.top + joyRect.height/2 };
  var maxRadius = joyRect.width * 0.4;

  function updateCenter() {
    joyRect = joystick.getBoundingClientRect();
    center.x = joyRect.left + joyRect.width/2;
    center.y = joyRect.top + joyRect.height/2;
  }

  window.addEventListener('resize', updateCenter);

  function joyStart(e) {
    e.preventDefault();
    e.stopPropagation();
    var touch = (e.changedTouches && e.changedTouches[0]) || e;
    if (joyActive) return;
    joyActive = true;
    joyId = touch.identifier !== undefined ? touch.identifier : 'mouse';
    handleJoyMove(touch);
  }

  function joyMove(e) {
    if (!joyActive) return;
    e.preventDefault();
    e.stopPropagation();
    
    var touch = null;
    if (e.changedTouches) {
      for (var i = 0; i < e.changedTouches.length; i++) {
        var t = e.changedTouches[i];
        if ((t.identifier !== undefined ? t.identifier : 'mouse') === joyId) {
          touch = t;
          break;
        }
      }
      if (!touch) return;
    } else {
      touch = e;
    }
    handleJoyMove(touch);
  }

  function joyEnd(e) {
    e.preventDefault();
    e.stopPropagation();
    joyActive = false;
    joyId = null;
    thumb.style.transform = 'translate(0px, 0px)';
    move.forward = 0;
    move.right = 0;
  }

  function handleJoyMove(touch) {
    var x = touch.clientX;
    var y = touch.clientY;
    var dx = x - center.x;
    var dy = y - center.y;
    var dist = Math.sqrt(dx*dx + dy*dy);
    var clamped = Math.min(dist, maxRadius);
    var nx = dx / (maxRadius || 1);
    var ny = dy / (maxRadius || 1);
    
    var tx = clamped * Math.cos(Math.atan2(dy, dx));
    var ty = clamped * Math.sin(Math.atan2(dy, dx));
    thumb.style.transform = 'translate(' + tx + 'px, ' + ty + 'px)';
    
    move.forward = -ny;
    move.right = nx;
  }

  joystick.addEventListener('touchstart', joyStart, {passive: false});
  joystick.addEventListener('touchmove', joyMove, {passive: false});
  joystick.addEventListener('touchend', joyEnd, {passive: false});
  joystick.addEventListener('mousedown', joyStart);

  window.addEventListener('mousemove', function(e) {
    if (joyActive) {
      e.preventDefault();
      joyMove(e);
    }
  });

  window.addEventListener('mouseup', function(e) {
    if (joyActive) {
      e.preventDefault();
      joyEnd(e);
    }
  });

  // Keyboard
  var keys = {};
  window.addEventListener('keydown', function(e) { keys[e.code] = true; });
  window.addEventListener('keyup', function(e) { keys[e.code] = false; });

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    
    var now = performance.now();
    var dt = Math.max((now - lastTime) / 1000, 0.001);
    lastTime = now;

    var kmForward = 0;
    var kmRight = 0;
    if (keys['KeyW']) kmForward += 1;
    if (keys['KeyS']) kmForward -= 1;
    if (keys['KeyD']) kmRight += 1;
    if (keys['KeyA']) kmRight -= 1;

    var forwardVal = Math.max(-1, Math.min(1, move.forward + kmForward));
    var rightVal = Math.max(-1, Math.min(1, move.right + kmRight));

    var forwardVec = new THREE.Vector3();
    camera.getWorldDirection(forwardVec);
    forwardVec.y = 0;
    forwardVec.normalize();

    var rightVec = new THREE.Vector3();
    rightVec.crossVectors(forwardVec, camera.up).normalize();

    var moveScale = speed * dt;
    camera.position.addScaledVector(forwardVec, forwardVal * moveScale);
    camera.position.addScaledVector(rightVec, rightVal * moveScale);

    renderer.render(scene, camera);
  }

  window.addEventListener('resize', function() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    updateCenter();
  });

  setStatus('Scene ready!');
  setTimeout(function() { statusEl.style.display = 'none'; }, 2000);
  animate();
}
</script>
</body>
</html>